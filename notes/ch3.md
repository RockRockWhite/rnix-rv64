
## 任务Task
一个计算阶段的执行过程（也是一段控制流）称为一个 `任务` 。

- 任务运行状态：任务从开始到结束执行过程中所处的不同运行状态：未初始化、准备执行、正在执行、已退出
- 任务控制块：管理程序的执行过程的任务上下文，控制程序的执行与暂停
- 任务相关系统调用：应用程序和操作系统直接的接口，用于程序主动暂停 `sys_yield` 和主动退出 `sys_exit`


## 函数调用规约
RISC-V 架构上的 C 语言调用规范可以在 [这里](https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf) 找到。 它对通用寄存器的使用做出了如下约定：

| 寄存器组 | 保存者       | 功能                                                 |
| -------- | ------------ | ---------------------------------------------------- |
| a0~a7    | 调用者保存   | 用来传递输入参数。其中的 a0 和 a1 还用来保存返回值。 |
| t0~t6    | 调用者保存   | 作为临时寄存器使用，在函数中可以随意使用无需保存。   |
| s0~s11   | 被调用者保存 | 作为临时寄存器使用，保存后才能在函数中使用。         |

剩下的 5 个通用寄存器情况如下：

- zero(x0) 之前提到过，它恒为零，函数调用不会对它产生影响；
- ra(x1) 是调用者保存的，不过它并不会在每次调用子函数的时候都保存一次，而是在函数的开头和结尾保存/恢复即可。虽然 `ra` 看上去和其它被调用者保存寄存器保存的位置一样，但是它确实是调用者保存的。
- sp(x2) 是被调用者保存的。这个是之后就会提到的栈指针寄存器。
- gp(x3) 和 tp(x4) 在一个程序运行期间都不会变化，因此不必放在函数调用上下文中。它们的用途在后面的章节会提到。

## 任务上下文
- 任务调度是以函数调用的形式执行的，进入调度函数switch后，ra会保存要回去的指令地址，因此上下文中应保存ra
- 除此之外，因为任务调度是函数调用，因此应该保存callee-saved寄存器。 `s0` - `s11`

```rust
/// TaskContext
/// args:
///     ra  用于保存ret位置
///     s   s0-s11寄存器是callee-saved寄存器，由于switch相当于一个函数调用，因此只需保存callee-saved寄存器
pub struct TaskContext {
    ra: usize,
    s: [usize; 12],
}
```